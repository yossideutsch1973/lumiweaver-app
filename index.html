<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LumiQuantum Health Weaver</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@latest"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 10px; background: #f0f0f0; }
        #video, #canvas { width: 100%; max-width: 400px; max-width: 100vw; }
        #canvas { display: none; }
        button { margin: 10px; padding: 10px; background: #007bff; color: white; border: none; cursor: pointer; touch-action: manipulation; border-radius: 5px; }
        button:disabled { background: #aaa; color: #fff; }
        #output { margin-top: 20px; padding: 10px; background: #fff; border: 1px solid #ccc; max-height: 200px; overflow-y: auto; }
        #hologram { width: 100%; height: 200px; background: #eee; }
        @media (max-width: 500px) {
            #hologram { height: 120px; }
        }
    </style>
</head>
<body>
    <h1>LumiQuantum Health Weaver</h1>
    <p>Demo: Scan skin or environment with camera for health insights. Disclaimer: For educational use only.</p>
    <video id="video" autoplay playsinline></video>
    <canvas id="canvas" width="300" height="300"></canvas>
    <button id="startCamera" aria-label="Start Camera">Start Camera</button>
    <button id="scan" aria-label="Scan & Analyze" disabled>Scan & Analyze</button>
    <button id="predict" aria-label="Predict Progression" disabled>Predict Progression</button>
    <button id="weave" aria-label="Weave Data (VLC)">Weave Data (VLC)</button>
    <button id="connectESP" aria-label="Connect ESP32">Connect ESP32</button>
    <div id="output" aria-live="polite"></div>
    <div id="hologram">Hologram Placeholder</div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const video = document.getElementById('video');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const output = document.getElementById('output');
            const startCameraBtn = document.getElementById('startCamera');
            const scanBtn = document.getElementById('scan');
            const predictBtn = document.getElementById('predict');
            let model = null;
            let lightSensor;
            let espDevice;
            let cameraStarted = false;

            // PWA Service Worker (basic offline stub)
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js')
                    .catch(err => appendOutput(`Service Worker Error: ${err}`));
            }

            // Helper to append output
            function appendOutput(msg) {
                output.innerText += msg + '\n';
                output.scrollTop = output.scrollHeight;
            }

            // Load MobileNet for AI analysis
            async function loadModel() {
                try {
                    model = await mobilenet.load();
                    appendOutput('AI Model Loaded.');
                    if (cameraStarted) {
                        scanBtn.disabled = false;
                        predictBtn.disabled = false;
                    }
                } catch (err) {
                    appendOutput(`Model Load Error: ${err.message}`);
                    alert('Model failed to load: ' + err.message);
                }
            }
            loadModel();

            // Function to add events for click and touchend
            function addMobileEventListener(element, handler) {
                element.addEventListener('click', handler);
                element.addEventListener('touchend', handler); // For mobile touch
            }

            // Access Camera
            addMobileEventListener(startCameraBtn, async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                    video.srcObject = stream;
                    cameraStarted = true;
                    appendOutput('Camera Started.');
                    if (model) {
                        scanBtn.disabled = false;
                        predictBtn.disabled = false;
                    }
                } catch (err) {
                    appendOutput(`Camera Error: ${err.message}`);
                    alert('Camera access failed: ' + err.message);
                }
            });

            // Access Ambient Light Sensor
            if ('AmbientLightSensor' in window) {
                try {
                    lightSensor = new AmbientLightSensor();
                    lightSensor.addEventListener('reading', () => {
                        appendOutput(`Ambient Light: ${lightSensor.illuminance} lux`);
                    });
                    lightSensor.start();
                } catch (err) {
                    appendOutput(`Sensor Error: ${err.message}`);
                }
            } else {
                appendOutput('Ambient Light Sensor not supported.');
            }

            // Scan: Capture frame, AI analyze (proxy hyperspectral)
            addMobileEventListener(scanBtn, async () => {
                if (!cameraStarted || !model) {
                    appendOutput('Camera or model not ready.');
                    return;
                }
                if (!video.srcObject) {
                    appendOutput('No camera stream available.');
                    return;
                }
                try {
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                    // Simple Compressive Sensing: Sparse RGB recovery (demo: average channels)
                    const sparseSignal = compressRGB(imgData);
                    const reconstructed = reconstructSparse(sparseSignal);
                    appendOutput(`Reconstructed Spectrum: R${reconstructed.r}, G${reconstructed.g}, B${reconstructed.b}`);
                    // AI Classification
                    const predictions = await model.classify(canvas);
                    if (predictions && predictions.length > 0) {
                        appendOutput(`AI Detection: ${predictions[0].className} (${predictions[0].probability.toFixed(2)})`);
                    } else {
                        appendOutput('AI Detection: No prediction.');
                    }
                    // Simulated PPG/Health
                    const redAvg = imgData.reduce((sum, val, idx) => idx % 4 === 0 ? sum + val : sum, 0) / (imgData.length / 4);
                    appendOutput(`Simulated Heart Rate: ${Math.round(60 + redAvg / 10)} bpm`);
                } catch (err) {
                    appendOutput(`Scan Error: ${err.message}`);
                }
            });

            // Predict: Chaos Theory (Lorenz for progression sim)
            addMobileEventListener(predictBtn, () => {
                try {
                    const trajectory = simulateLorenz(10, 28, 8/3, 0.01, 100);
                    appendOutput(`Chaotic Prediction: Final X=${trajectory.x.toFixed(2)}`);
                    document.getElementById('hologram').innerText = `Trajectory: ${trajectory.x.toFixed(2)}, ${trajectory.y.toFixed(2)}, ${trajectory.z.toFixed(2)}`;
                } catch (err) {
                    appendOutput(`Predict Error: ${err.message}`);
                }
            });

            // Weave: VLC Modulation via Canvas
            addMobileEventListener(document.getElementById('weave'), () => {
                try {
                    const data = 'HealthData';
                    const binary = data.split('').map(c => c.charCodeAt(0).toString(2).padStart(8, '0')).join('');
                    modulateCanvas(binary);
                    appendOutput('VLC Weaving Started.');
                } catch (err) {
                    appendOutput(`Weave Error: ${err.message}`);
                }
            });

            // Connect ESP32 via Web Bluetooth
            addMobileEventListener(document.getElementById('connectESP'), async () => {
                if (!navigator.bluetooth) {
                    appendOutput('Web Bluetooth not supported in this browser.');
                    return;
                }
                try {
                    espDevice = await navigator.bluetooth.requestDevice({ filters: [{ services: ['0000ffe0-0000-1000-8000-00805f9b34fb'] }] });
                    const server = await espDevice.gatt.connect();
                    appendOutput('ESP32 Connected.');
                } catch (err) {
                    appendOutput(`Bluetooth Error: ${err.message}`);
                    alert('Bluetooth failed: ' + err.message);
                }
            });

            // Helpers (unchanged)
            function compressRGB(data) {
                let r=0, g=0, b=0;
                for (let i=0; i<data.length; i+=4) { r+=data[i]; g+=data[i+1]; b+=data[i+2]; }
                return { r: r/(data.length/4), g: g/(data.length/4), b: b/(data.length/4) };
            }
            function reconstructSparse(compressed) {
                return { r: compressed.r * 1.1, g: compressed.g * 0.9, b: compressed.b };
            }
            function simulateLorenz(sigma, rho, beta, dt, steps) {
                let x=1, y=1, z=1;
                for (let i=0; i<steps; i++) {
                    const k1x = sigma * (y - x);
                    const k1y = x * (rho - z) - y;
                    const k1z = x * y - beta * z;
                    x += dt * k1x;
                    y += dt * k1y;
                    z += dt * k1z;
                }
                return {x, y, z};
            }
            function modulateCanvas(binary) {
                let idx = 0;
                const interval = setInterval(() => {
                    ctx.fillStyle = binary[idx] === '1' ? '#fff' : '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    idx = (idx + 1) % binary.length;
                }, 100);
                setTimeout(() => clearInterval(interval), 5000);
            }
        });
    </script>
</body>
</html>
